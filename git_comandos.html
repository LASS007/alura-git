<!-- "ls" para ver los archivos o carpetas en la ubicacion actual
"cd" + directorio para entras a la carpeta
 
"git init" para inicializar el repositorio

 "git status" para asegurarte que estas en un repositorio de Git y que el archivo esta siendo reconocido

"git add ." para añadir el seguimiento de todos los archivos de la carpeta

"git add (nombre del archivo)" para añadir individualmente
(use "git rm --cached <file>..." to unstage) 

    "git commit -m "mensaje" " para crear un guardado y un mensaje corto pero descriptivo

 HEAD: Estado actual de nuestro código, es decir, donde nos colocó Git

Working tree: Lugar donde los archivos realmente están siendo almacenados

index: Lugar donde Git almacena lo que será commiteado, es decir, la ubicación entre el working tree y el repositorio de Git en sí.

*Creamos un archivo .gitignore y dentro de agregamos los archivos que no quiero que git vea 
agregamos .gitignore y hacemos commit

**se dice que nunca hay que hacer un commit de un archivo que no funciona, solo en cada modificacion significativa se tiene que crear un commit, aunque si dice el jefe mira una modificacion rapida aqui si no es significativa entonces no. Pero no exixte una regla de cuando commitear, pero existen recomendaciones, siempre que exista una alteracion hay que comitear, cuando se corrige un bug, para que al final un conjunto de commits generen un sistema como un todo 

"cd .." regresa un espacio atras o carpeta

mkdir (nombre de carpeta) -crea una nueva carpeta

"git init --bare" genera un espacio paar solo guardas las modificaciones conviertiendolo en un repositorio remoto; Con este comando creamos un repositorio que no tendrá la working tree, o sea, no contendrá una copia de nuestros archivos. Como el repositorio servirá solo como servidor, para que otros miembros del equipo sincronicen sus trabajos, disminuimos espacio de almacenamiento de esta forma.

"git remote" sirve para saber que servidores esta reconociendo git actualmente

"git remote -v" sirve para saber que servidores esta reconociendo git actualmente y su direccion de ubicacion (fetch = lugar de donde vamos a recibir) (push = donde vamos a poner)

"git remote add (nombre que le quiero identificar) (ruta donde se encuentra)" ejemplo $ git remote add servidorlocal C:/Users/LASS/Documents/ALURA/servidor_g ; De esta forma tendremos un link de nuestro repositorio local con el repositorio remoto, que llamamos de nombre-repositorio, que está almacenado en camino/del/repositorio.

git clone /c/Users/LASS/Documents/ALURA/servidor_git/ proyecto_invitado  ** esto clonara el servidor en una carpeta creada con nombre proyecto_invitado dentro de la carpeta recien creada "invitado"

"cd ../.." este comando me permite ir dos veces atras en carpetas

"git push servidorlocal master" este comando empuja datos al servidor local del master

origin resultado de git remote es el nombre por defecto que git asigana a un repositorio nuevo
$ git remote rename origin local con este comando cambiamos el nombre de origin a local

Entonces el proceso de guardado en el servidor seria git status para verificar que cambios hay
luego añadirlo con git add (archivo) luego git commit -m "texto identificador" ; y empujar al servior con  git push servidorlocal master de servidorlocal que es como le llamamos al espacio de invitado al serviodr master
-si cambiamos de usuario tenemos que hacer un push y luego un "git log -p" para ver las modificaciones por linea y para salir es con :q 

Además de agregar repositorios remotos para sincronizar los datos, vimos que git clone trae un repositorio remoto a nuestra computadora, creando un repositorio local.

Al modificar el código en nuestro repositorio local, ¿cómo enviamos las modificaciones a el repositorio remoto?
git push [repositorio] master ; De esta forma enviamos las modificaciones de nuestra Branch master (hablaremos más sobre branches dentro de poco) hacia el repositorio remoto. Basta con substituir [repositorio] por el nombre que dimos al repositorio al agregarlo. Ahora, para traer los datos que están en el repositorio remoto, podemos utilizar git pull [repositorio] master.

-con la cuenta de github se inicia un repositrio en la nube de la siguiente manera 
añadir el repositorio
git remote add origin https://github.com/LASS007/alura-git.git

-este comando no lo saltamos donde main ahora es master por temas politicos o sociales
git branch -M main

hacer un pusch y -u significa que cada vez que hacemos un push a nuetra branch master siempre ira a nuestra origin al parecer en automatico por eso nos da mejor control no agregarlo y hacer cada vez 
git push -u origin main

-asi quedria pues
git push origin master

"git branch" ejecuta para saber en que rama estoy

"git branh titulo" se crea una brach con nombre titulo

"git checkout titulo" cambio a trabajar en la brach titulo
"git commit" paar guardar ramas

"git checkout -b lista" cambiara a lista y crear rama "-b" (branch) lista

-Ahora que cree la branch titulo y lista con "git log" puedo ver los cambias de master hasta donde se creo la brach y se dice que master es el proyecto final ahora como actualizar los cambios de titulo lista a master? 

git checkout master
y

git merge titulo

De esta forma colocaremos el HEAD en la Branch master, o sea, haremos que nuestro código esté en el estado que lo dejamos con el últimocommit en master. Después, uniremos el trabajo de la Branch titulo con la Branch actual (master).

"git log --graph" manda un historial de cambios y sales con q o :q

ctrl + C para parar la linea que estamos modificando

El merge junta los trabajos y genera un merge commit. El rebase aplica los commits de otra Branch en la Branch actual. 
 ->